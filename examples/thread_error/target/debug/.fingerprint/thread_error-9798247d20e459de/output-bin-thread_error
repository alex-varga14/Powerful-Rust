{"message":"closure may outlive the current function, but it borrows `my_vec`, which is owned by the current function","code":{"code":"E0373","explanation":"A captured variable in a closure may not live long enough.\n\nErroneous code example:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure as shown in the previous code example.\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behavior is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n\nThis error may also be encountered while using `async` blocks:\n\n```compile_fail,E0373,edition2018\nuse std::future::Future;\n\nasync fn f() {\n    let v = vec![1, 2, 3i32];\n    spawn(async { //~ ERROR E0373\n        println!(\"{:?}\", v)\n    });\n}\n\nfn spawn<F: Future + Send + 'static>(future: F) {\n    unimplemented!()\n}\n```\n\nSimilarly to closures, `async` blocks are not executed immediately and may\ncapture closed-over data by reference. For more information, see\nhttps://rust-lang.github.io/async-book/03_async_await/01_chapter.html.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":175,"byte_end":181,"line_start":11,"line_end":11,"column_start":25,"column_end":31,"is_primary":false,"text":[{"text":"        add_to_vec(&mut my_vec);","highlight_start":25,"highlight_end":31}],"label":"`my_vec` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":146,"byte_end":148,"line_start":10,"line_end":10,"column_start":19,"column_end":21,"is_primary":true,"text":[{"text":"    thread::spawn(|| {","highlight_start":19,"highlight_end":21}],"label":"may outlive borrowed value `my_vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function requires argument type to outlive `'static`","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":132,"byte_end":190,"line_start":10,"line_end":12,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    thread::spawn(|| {","highlight_start":5,"highlight_end":23},{"text":"        add_to_vec(&mut my_vec);","highlight_start":1,"highlight_end":33},{"text":"    });","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"to force the closure to take ownership of `my_vec` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":146,"byte_end":146,"line_start":10,"line_end":10,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"    thread::spawn(|| {","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":"move ","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0373]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: closure may outlive the current function, but it borrows `my_vec`, which is owned by the current function\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:10:19\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmay outlive borrowed value `my_vec`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        add_to_vec(&mut my_vec);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m`my_vec` is borrowed here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function requires argument type to outlive `'static`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:10:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    thread::spawn(|| {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        add_to_vec(&mut my_vec);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    });\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|______^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: to force the closure to take ownership of `my_vec` (and any other referenced variables), use the `move` keyword\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    thread::spawn(\u001b[0m\u001b[0m\u001b[38;5;10mmove \u001b[0m\u001b[0m|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\n\n"}
{"message":"cannot borrow `my_vec` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":146,"byte_end":148,"line_start":10,"line_end":10,"column_start":19,"column_end":21,"is_primary":false,"text":[{"text":"    thread::spawn(|| {","highlight_start":19,"highlight_end":21}],"label":"first mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":197,"byte_end":212,"line_start":14,"line_end":14,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    my_vec.push(34)","highlight_start":5,"highlight_end":20}],"label":"second mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":175,"byte_end":181,"line_start":11,"line_end":11,"column_start":25,"column_end":31,"is_primary":false,"text":[{"text":"        add_to_vec(&mut my_vec);","highlight_start":25,"highlight_end":31}],"label":"first borrow occurs due to use of `my_vec` in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":132,"byte_end":190,"line_start":10,"line_end":12,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    thread::spawn(|| {","highlight_start":5,"highlight_end":23},{"text":"        add_to_vec(&mut my_vec);","highlight_start":1,"highlight_end":33},{"text":"    });","highlight_start":1,"highlight_end":7}],"label":"argument requires that `my_vec` is borrowed for `'static`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0499]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot borrow `my_vec` as mutable more than once at a time\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:14:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mfirst mutable borrow occurs here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m_____|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        add_to_vec(&mut my_vec);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mfirst borrow occurs due to use of `my_vec` in closure\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    });\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|______-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument requires that `my_vec` is borrowed for `'static`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    my_vec.push(34)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9msecond mutable borrow occurs here\u001b[0m\n\n"}
{"message":"aborting due to 2 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 2 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0373, E0499.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0373, E0499.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0373`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0373`.\u001b[0m\n"}
